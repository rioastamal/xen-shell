#!/usr/bin/perl -w

=head1 NAME

xen-shell - Provide a command line interface to control Xen guests.

=cut

=head1 SYNOPSIS

  xen-shell [options]

  Options:

   --help     Show brief help intstructions.
   --manual   Show more complete help.
   --version  Show the version of the software.

=cut

=head1 DESCRIPTION

  xen-shell aims to provide a simple command line interface
 which will allow a user to control a single Xen instance which
has the same name as their Unix username.

  The shell provides several commands to control the instance
 and supports such featurs as:

=over 8

=item Command line completion

=item Command history

=item Readline support

=item The ability to run within GNU Screen to allow longrunning jobs to be completed "offline".

=back

=cut

=head1 IMPLEMENTATION NOTES

  There now follows a brief overview of the code.

=cut


use strict;
use warnings;
use English;
use Getopt::Long;
use Pod::Usage;


#
#  Version number
#
my $VERSION   = '$Revision: 1.35 $';
if ( $VERSION =~ /(1.[0-9.]+) / ) { $VERSION = $1; }


#
# Get the username of the person who is currently running the software.
#
my $USER = getpwuid( $REAL_USER_ID );


#
#  Dispatch table which contains the mappings between the commands
# we make available and the routine which implements that behaviour
# along with the relevant help text.
#
#  This is a hash of hashes.  Obviously.
#
my %dispatch =
  (
   "boot" =>
     {
        sub => \&do_boot,
       help => "Start the Xen guest, if it is not running.",
     },
   "console" =>
     {
        sub => \&do_console,
       help => "Connect to the serial console of the Xen instance using GNU Screen.\n\nTo exit the serial prompt type 'Ctrl+]'\nYou may instead exit screen with 'Ctrl+a k', or 'Ctrl+a d'.",
     },
   "exit" =>
     {
        sub => \&do_exit,
       help => "Exit this shell.",
     },
   "help" =>
     {
        sub => \&show_help,
       help => "Show help about the specified command, or all commands.",
     },
  "quit" =>   # Dupe: exit
     {
        sub => \&do_exit,
       help => "Exit this shell.",
     },
   "reboot" =>
     {
        sub => \&do_reboot,
       help => "Reboot the Xen guest.",
     },
   "reimage" =>
     {
        sub => \&do_reimage,
       help => "Erase your Xen guest and reinitialise it to a fresh installation of Sarge.",
     },
   "serial" => # Dupe: console
     {
        sub => \&do_console,
       help => "Connect to the serial console of the Xen instance using GNU Screen.\n\nTo exit the serial prompt type 'Ctrl+]'\nYou may instead exit screen with 'Ctrl+a k', or 'Ctrl+a d'.",
     },
   "shutdown" =>
     {
        sub => \&do_shutdown,
       help => "Shutdown the Xen guest.",
     },
   "status" =>
     {
        sub => \&show_status,
        help => "Show whether the Xen guest is running or not.",
     },
   "uptime" =>
     {
        sub => \&show_uptime,
        help => "Show the uptime of the host & guest systems.",
     },
   "version" =>
     {
        sub => \&show_version,
        help => "Show the version of this shell, and of Xen.",
     },
  );


#
#  Parse the command line arguments.
#
parseCommandLineArguments();


#
# Sanity check our host and user.
#
sanityCheck();


#
# Show our banner.
#
showBanner();


#
#  Create the readline interface.
#
my $term = createTerm();


#
#  Load any command history which might be present.
#
loadHistory( $term );


#
#  Run our command loop.
#
runMainLoop( $term );


#
#  Never reached
#
exit;




=head2 parseCommandLineArguments

  Parse any command line options which might be present

=cut

sub parseCommandLineArguments
{
    my $SHOW_HELP    = 0;
    my $SHOW_MANUAL  = 0;
    my $SHOW_VERSION = 0;

    #
    #  Parse options.
    #
    GetOptions(
              "help",         \$SHOW_HELP,
              "manual",       \$SHOW_MANUAL,
              "version",      \$SHOW_VERSION
             );

    pod2usage(1) if $SHOW_HELP;
    pod2usage(-verbose => 2 ) if $SHOW_MANUAL;

    if ( $SHOW_VERSION )
    {
       print "xen-shell v$VERSION\n";
       exit;
    }
}


=head2 sanityCheck

 Sanity check that we can load the modules we require, and also make sure
the current user has a xen guest on this host machine.

=cut

sub sanityCheck
{
    #
    #  Test we have the perl modules we need.
    #
    BEGIN {
        eval {
            require Term::ReadLine;
            require Term::ReadLine::Gnu;
        };
    };
    if ( $@ )
    {
        print "Package 'Term::ReadLine::Gnu' not installed.\n";
        print "Aborting\n";
        exit;
    }

    #
    #  Test that the current user has a sane name
    #
    if ( $USER !~ /^([a-zA-Z]+)$/ )
    {
        print "User $USER contains non-alphabetical characters\n";
        print "Aborting\n";
        exit;
    }

    #
    #  Test that the user has a Xen guest
    #
    if ( ! -e "/etc/xen/$USER.cfg" )
    {
        print "User '$USER' doesn't have a Xen guest on this host.\n";
        print "Aborting\n";
        exit;
    }
}



=head2 showBanner

 Show the banner of this shell - used when we start up.

=cut

sub showBanner
{
    print "xen-shell v$VERSION - type 'help' for help.\n";
}



=head2 createTerm

  Create the terminal interface, complete with command completion.

=cut

sub createTerm
{
    my $term = new Term::ReadLine 'xen-shell';

    #
    # Process our dispatch table to determine which commands
    # are available.
    #
    my @cmds = ();
    foreach my $cmd ( keys %dispatch )
    {
        push @cmds, $cmd;
    }

    #
    #  Add completion
    #
    my $attribs = $term->Attribs;
    $attribs->{completion_entry_function} = $attribs->{list_completion_function};
    $attribs->{completion_word}           = \@cmds;

    #
    #  Return it
    #
    return( $term );
}



=head2 loadHistory

  If the user has a xen-shell history load it up.

=cut

sub loadHistory
{
    my ( $term ) = ( @_ );

    #
    #  Load the file.
    #
    my $file = $ENV{'HOME'} . "/" . ".xen-shell";
    if ( -e $file )
    {
        $term->ReadHistory( $file );
    }
}




=head2 runMainLoop

  Run the input reading + dispatching loop.   We use the dispatch
 table already defined to handle input.

  Parsing of command line input is extremely minimal - we break the
 input line into "word" which is the first whitespace deliminated
 token on the line and "args" which is the remainder of the line.

  This is sufficient for our purposes.

=cut

sub runMainLoop
{
    my ( $term ) = ( @_ );

    #
    #  Command loop.
    #
    while ( defined (my $line = $term->readline('xen-shell> ')) )
    {
        # Ignore empty lines.
        next if ( !length( $line ) );

        # Strip leading and trailing whitespace.
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;

        # If we have arguements then split them up.
        my ($word, @args) = split( /[ \t]/, $line );

        # Lookup command in our dispatch table.
        my $cmd = $dispatch{ lc( $word ) };

        if ( $cmd )
        {
            # Call the function with any arguments we might have.
            $cmd->{'sub'}->( join( " ", @args ) );

            # Add a successful line to our history
            $term->add_history( $line );
        }
        else
        {
            if ( defined( $word ) && length( $word ) )
            {
                print "Unknown command: '$word' - type 'help' for help.\n";
            }
        }
    }
}




=head2 show_uptime

  Show uptime of the guest.

=cut

sub show_uptime
{
    my $host_uptime = `uptime`;
    chomp( $host_uptime );
    print "Host : $host_uptime\n";

    my $seconds = "";
    my $cmd     = "sudo xm list --long $USER 2>/dev/null";

    open( RUNNING, $cmd . "|" );
    foreach my $line ( <RUNNING> )
    {
        if ( $line =~ /\(up_time[ \t]*([0-9]+)/ )
        {
            $seconds= $1;
        }
    }
    close( RUNNING );

    if ( defined( $seconds ) && length( $seconds ) )
    {
        my $days  = int($seconds/(24*60*60));
        my $hours = ($seconds/(60*60))%24;
        my $mins  = ($seconds/60)%60;
        my $secs  = $seconds%60;

        if ( length( $hours ) < 2 ) { $hours = "0" . $hours ; }
        if ( length( $mins ) < 2 )  { $mins  = "0" . $mins ; }
        if ( length( $secs ) < 2 )  { $secs  = "0" . $secs ; }

        print"Guest: $days days $hours:$mins:$secs\n";
    }
    else
    {
        print "Guest: Uptime not found\n";
    }
}


=head2 show_status

  Show status of the guest system:  Running/Shutdown

=cut

sub show_status
{
    my $running = 0;

    #
    # See if the instance is running
    #
    my $cmd = "sudo xm list $USER 2>/dev/null | grep $USER";
    my $out = `$cmd`;
    if ( length( $out ) ) { $running = 1; }

    #
    # Show state.
    #
    if ( $running )
    {
        print "Guest : Running\n";

        my $seconds = "";
        my $cmd     = "sudo xm list --long $USER 2>/dev/null";

        open( RUNNING, $cmd . "|" );
        foreach my $line ( <RUNNING> )
        {
            if ( $line =~ /\(up_time[ \t]*([0-9]+)/ )
            {
                $seconds= $1;
            }
        }
        close( RUNNING );

        if ( defined( $seconds ) && length( $seconds ) )
        {
            my $days  = int($seconds/(24*60*60));
            my $hours = ($seconds/(60*60))%24;
            my $mins  = ($seconds/60)%60;
            my $secs  = $seconds%60;

            if ( length( $hours ) < 2 ) { $hours = "0" . $hours ; }
            if ( length( $mins ) < 2 )  { $mins  = "0" . $mins ; }
            if ( length( $secs ) < 2 )  { $secs  = "0" . $secs ; }

            print"Uptime: $days days $hours:$mins:$secs\n";
        }
    }
    else
    {
        print "Guest: Shutdown\n";
    }
}



=head2 show_help

  Show the user some help

=cut

sub show_help
{
    my ( $term ) = ( @_ );

    #
    #  Help on a single command
    #
    if ( ( defined( $term ) ) && ( length( $term ))  )
    {
        foreach my $cmd ( split( /[ \t]/, $term ) )
        {
            print "\nCommand: $cmd\n\n";

            # Lookup command in our dispatch table.
            my $c = $dispatch{ lc( $cmd ) };
            if ( $c )
            {
                print $c->{'help'} . "\n";
            }
            else
            {
                print "Unknown command '$cmd' - no help text available\n";
            }
        }
        return;
    }

    print <<E_O_HELP;

xen-shell v$VERSION

The following commands are available within this shell:

  boot      Boot your Xen guest.
  console   Gain access to your Xen guest via the serial console.
  exit      Exit this shell.
  help      Show general, or command-specific, help information.
  reboot    Reboot your Xen guest.
  reimage   Reset your system to a pristine installation of Sarge.
  shutdown  Shut down your Xen guest.
  status    Show the status of your Xen guest.
  uptime    Show the uptime information of the host and guest systems.
  version   Show the version of this shell, and of Xen.

  For command-specific help run "help command".

E_O_HELP
}




=head2 show_help

  Show the user the version of this shell.

=cut

sub show_version
{
    my $xen = "";

    my $cmd     = "sudo xm info 2>/dev/null";

    open( INFO, $cmd . "|" );
    foreach my $line ( <INFO> )
    {
        if ( $line =~ /^xen_major.*: (.*)$/ )
        {
            $xen .= $1;
        }
        if ( $line =~ /^xen_minor.*: (.*)$/ )
        {
            $xen .= "." . $1;
        }
        if ( $line =~ /^xen_extra.*: (.*)$/ )
        {
            $xen .= $1;
        }
    }
    close( INFO );
    print "xen-shell $VERSION";
    if ( length( $xen ) )
    {
        print " running on Xen version $xen";
    }

    print "\n";
}



=head2 do_reboot

  Reboot the instance.

=cut

sub do_reboot
{
    print "Rebooting instance: $USER\n";
    system( "sudo xm reboot $USER" );
}



=head2 do_reimage

  Allow the machine to be reinitialised to a fresh installation of
 their Xen guest.  This ultimately invokes ~$USER/image.sh to do
 the work.

=cut

sub do_reimage
{
    if (! -x "/home/$USER/image.sh" )
    {
        print "There is no reimaging script for user $USER\n";
        print "Skipping.\n";
        return;
    }

    print "Reimaging instance: $USER\n";

    #
    # See if the instance is running
    #
    my $running = 0;
    my $cmd = "sudo xm list $USER 2>/dev/null | grep $USER";
    my $out = `$cmd`;
    if ( length( $out ) )
    {
        print "Xen guest running.\n";
        print "Please run 'shutdown' first\n";
        return;
    }
    else
    {
        print "Machine not running, proceeding\n";
    }

    system( "/usr/local/bin/xm-reimage $USER" );
    print "You may now boot your installation\n";
}



=head2 do_shutdown

  Shutdown the instance.

=cut

sub do_shutdown
{
    print "Shutting down instance: $USER\n";
    system( "sudo xm shutdown $USER" );
}


=head2 do_boot

  Start the instance.

=cut

sub do_boot
{
    print "Booting instance: $USER\n";
    system( "sudo xm create $USER.cfg" );
    print "Use 'console' to see the bootup messages.\n";
}


=head2 do_console

  Run GNU Screen with the console output of Xen.

=cut

sub do_console
{
    print "Running console for $USER - exit with Ctrl+]\n";
    system( "sudo xm console $USER" );
}


=head2 do_exit

 Exit this shell

=cut

sub do_exit
{
    my $file = $ENV{'HOME'} . "/" . ".xen-shell";

    $term->WriteHistory( $file );

    exit;
}


=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

 $Id: xen-shell,v 1.35 2006-08-06 22:10:34 steve Exp $

=cut

=head1 LICENSE

Copyright (c) 2005-2006 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut
