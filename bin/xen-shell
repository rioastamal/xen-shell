#!/usr/bin/perl -w

=head1 NAME

xen-shell - Provide a console interface to control Xen guests.

=cut


=head1 SYNOPSIS

  xen-shell [options]

  Options:

   --help     Show brief help intstructions.
   --manual   Show more complete help.
   --version  Show the version of the software.

=cut


=head1 DESCRIPTION

  xen-shell provides a simple console interface to allow a user to
 control a single Xen instance which is running upon the localhost.

  The Xen instance is assumed to have the same name as the users login
 name, and will not work if that isn't the case.

  Features include:

=over 8

=item Command line completion

=item Command history

=item The ability to run within GNU Screen to allow long-running jobs to be completed "offline".

=back

=cut


=head1 REIMAGING SUPPORT

  The shell has a built-in "reimage" command which can be used by users
 to reinitialize their system.

  The reimage command itself does nothing, it merely executes the file
 "image.sh" from the users home directory, it is assumed that you will
 write your own script - perhaps to invoke "xen-create-image" to do
 the real job.

  A sample script looks like this:

=for example begin
   #!/bin/sh
   #
   # Reimaging script for the user skx.
   #

   xen-create-image --hostname=skx.xen-hosting.net --ip=1.2.3.4 \
      --size=9.5Gb --swap=512Mb --memory=256Mb --force

=for example end

  If ~$USER/image.sh doesn't exist, or isn't executable, this command
 will be disabled.

=cut


=head2 REVERSE DNS SUPPORT

  This shell contains a built-in system for allowing a Xen-shell user to
 manipulate reverse DNS entries for IP addresses.  The shell itself doesn't
 do this, instead a user will manipulate a simple text file in their home
 directory.

  Create the file /home/$USER/ips.txt with contents of the following form:

=for example begin

   192.168.1.1 foo.my.flat
   192.168.1.2 bar.my.flat
   192.168.1.3 baz.my.flta

=for example end

  If this file is present then the "rdns" command will be available to
 that user.  The "rdns" command, when executed with no arguments will
 simply display this file.

  When the user attempts to set reverse DNS the file will be updated.

  It is assumed you will have your own cronjob to actually read these
 files and perform the DNS updates, the shell support is just half the
 implementation.

  If the file doesn't exist, or isn't writable, then the command will
 be disabled.

=cut


=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

 $Id: xen-shell,v 1.56 2006-12-10 17:31:21 steve Exp $

=cut


=head1 LICENSE

Copyright (c) 2005-2006 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut





use strict;
use warnings;
use English;
use Getopt::Long;
use Pod::Usage;


#
#  Version number of this script, taken from the CVS revision number.
#
my $RELEASE   = '0.6';
my $VERSION   = '$Revision: 1.56 $';
if ( $VERSION =~ /1.([0-9.]+) / ) { $VERSION = $1; }




#
#  Dispatch table which contains the mapping between the commands
# we make available and the routine which implements that behaviour.
#
#  The help-text is also specified here.
#
#
my %dispatch =
  (
   "boot" =>
     {
        sub => \&do_boot,
       help => "Start the Xen guest, if it is not running.",
     },
   "console" =>
     {
        sub => \&do_console,
       help => "Connect to the serial console of the Xen instance using GNU Screen.\n\nTo exit the serial prompt type 'Ctrl+]'\nYou may instead exit screen with 'Ctrl+a k', or 'Ctrl+a d'.",
     },
   "exit" =>
     {
        sub => \&do_exit,
       help => "Exit this shell.",
     },
   "help" =>
     {
        sub => \&show_help,
       args => "[command]",
       help => "Show help about the specified command, or all commands if no command is specified.",
     },
  "passwd" =>
     {
        sub => \&do_password,
       help => "Change your login password.",
     },
  "quit" =>   # Dupe: exit
     {
        sub => \&do_exit,
       help => "Exit this shell.",
     },
   "rdns" =>
     {
       sub  => \&do_rdns,
       args => "[ipaddress some.host.name]",
       help => "Setup Reverse DNS for allocated IP addresses.\n\nWhen called with no arguments show current reverse DNS details.",
     },
   "reboot" =>
     {
        sub => \&do_reboot,
       help => "Reboot the Xen guest.",
     },
   "reimage" =>
     {
        sub => \&do_reimage,
       help => "Erase your Xen guest and reinitialise it to a fresh installation of Sarge.",
     },
   "serial" => # Dupe: console
     {
        sub => \&do_console,
       help => "Connect to the serial console of the Xen instance using GNU Screen.\n\nTo exit the serial prompt type 'Ctrl+]'\nYou may instead exit screen with 'Ctrl+a k', or 'Ctrl+a d'.",
     },
   "shutdown" =>
     {
        sub => \&do_shutdown,
       help => "Shutdown the Xen guest.",
     },
   "status" =>
     {
        sub => \&show_status,
        help => "Show whether the Xen guest is running or not.",
     },
   "uptime" =>
     {
        sub => \&show_uptime,
        help => "Show the uptime of the host & guest systems.",
     },
   "version" =>
     {
        sub => \&show_version,
        help => "Show the version of this shell, and of Xen.",
     },
  );



#
# Find the username of the person running this script.
#
my $USER = getpwuid( $REAL_USER_ID );


#
#  Parse any command line arguments which might be present.
#
parseCommandLineArguments();


#
# Sanity check our host and user.
#
sanityCheck();


#
# Remove commands the user can't access.
#
removeCommands();


#
# Show our banner.
#
showBanner();


#
#  Create the readline interface.
#
my $term = createTerminal();


#
#  Load any command history which might be present.
#
loadHistory( $term );


#
#  Run our command loop - note this never returns.
#
runMainLoop( $term );


#
#  Never reached
#
exit;




=begin doc

  Parse any command line options which might be present

=end doc

=cut

sub parseCommandLineArguments
{
    my $SHOW_HELP    = 0;
    my $SHOW_MANUAL  = 0;
    my $SHOW_VERSION = 0;

    #
    #  Parse options.
    #
    GetOptions(
              "help",         \$SHOW_HELP,
              "manual",       \$SHOW_MANUAL,
              "version",      \$SHOW_VERSION
             );

    pod2usage(1) if $SHOW_HELP;
    pod2usage(-verbose => 2 ) if $SHOW_MANUAL;

    if ( $SHOW_VERSION )
    {
       print "xen-shell v$RELEASE.$VERSION\n";
       exit;
    }
}




=begin doc

 Sanity check that we can load the Perl modules we require.

 Also make sure the current user has a Xen guest on this host machine.

=end doc

=cut

sub sanityCheck
{
    #
    #  Test we have the perl modules we need.
    #
    BEGIN {
        eval {
            require Term::ReadLine;
            require Term::ReadLine::Gnu;
        };
    };
    if ( $@ )
    {
        print "Package 'Term::ReadLine::Gnu' not installed.\n";
        print "Aborting\n";
        exit;
    }

    #
    #  Test that the current user has a sane name only letters digits
    # and the underscore are allowed
    #
    if ( $USER !~ /^([a-zA-Z0-9_-]+)$/ )
    {
        print "Username '$USER' contains disallowed characters.\n";
        print "Aborting\n";
        exit;
    }

    #
    #  Test that the user has a Xen guest present upon this host.
    #
    #  We parse each file beneath /etc/xen and look for one with
    # a name equal to the $USER.
    #
    if ( ! defined( findInstanceFor( $USER ) ) )
    {
        print "User '$USER' doesn't have a Xen guest on this host.\n";
        print "(The file '/etc/xen/$USER.cfg' does not exist.)\n";
        print "Aborting\n";
        exit;
    }
}




=begin doc

  Does the user have an instance upon this host?  If so return the
 name, otherwise return undef.

  This means that the configuration file can be called anything, so
 long as it contains a line "name = 'xxxx'" which matches the username
 'xxxx'.

=end doc

=cut

sub findInstanceFor
{
    my( $username ) = ( @_ );

    # result
    my $result = undef;

    foreach my $file ( sort( glob( "/etc/xen/*" ) ) )
    {
        # skip non-files.
        next if ( ! -f $file );

        # open and read the file.
        open( CFG, "<", $file ) or die "Failed to open $file - $!";
        my @contents = <CFG>;
        close( CFG);

        # process each line.
        foreach my $line ( @contents )
        {
            # skip blank lines.
            next if ( ! defined( $line ) || ! length( $line ) );
            chomp( $line );

            # look for "name = 'xx'";
            if ( $line =~ /^[ \t]*name[ \t]*=[ \t]*['"]*([^'"]+)['"]*[ \t]*$/i )
            {
                my $name = $1;
                # found the right one?
                if ( lc( $name ) eq ( lc( $username ) ) )
                {
                    return $name;
                }
            }

        }
    }
    return undef;
}



=begin doc

  Remove any commands which the current user cannot use.

  This means:

    - We remove "rdns" if ~/ips.txt is missing or non-writable.
    - We remove "reimage" if ~/image.sh isn't present and executable.
    - We remove "passwd" if ~/.ssh/authorized_keys is present and non-empty.

=end doc

=cut

sub removeCommands
{
    #
    #  reimage
    #
    if ( ( ! -e "/home/$USER/image.sh" ) ||
         ( ! -x "/home/$USER/image.sh" ) )
    {
        $dispatch{ 'reimage' } = undef;
        delete( $dispatch{ 'reimage' } );
    }

    #
    #  rdns
    #
    if ( ( ! -e "/home/$USER/ips.txt" ) ||
         ( ! -w "/home/$USER/ips.txt" ) )
    {
        $dispatch{ 'rdns' } = undef;
        delete( $dispatch{ 'rdns' } );
    }

    #
    #  Password changing isn't available if key-based auth is used.
    #
    if ( -s "/home/$USER/.ssh/authorized_keys" )
    {
        $dispatch{ 'passwd' } = undef;
        delete( $dispatch{ 'passwd' } );
    }
}



=begin doc

 Show the startup banner for the shell.

=end doc

=cut

sub showBanner
{
    print "xen-shell v$RELEASE.$VERSION - type 'help' for help.\n";
}



=begin doc

  Create the terminal interface, complete with command completion.

  Rather than hard-wiring the commands which are available we take them
 from our global dispatch table.

=end doc

=cut

sub createTerminal
{
    my $term = new Term::ReadLine 'xen-shell';

    #
    # Process our dispatch table to determine which commands
    # are available.
    #
    my @cmds = ();
    foreach my $cmd ( keys %dispatch )
    {
        push @cmds, $cmd;
    }

    #
    #  Add completion
    #
    my $attribs = $term->Attribs;
    $attribs->{completion_entry_function} = $attribs->{list_completion_function};
    $attribs->{completion_word}           = \@cmds;

    #
    #  Return it
    #
    return( $term );
}



=begin doc

  If the user has a history present in ~/.xen-shell load it up.

=end doc

=cut

sub loadHistory
{
    my ( $term ) = ( @_ );

    #
    #  Load the file, if it exists.
    #
    my $file = $ENV{'HOME'} . "/" . ".xen-shell";
    if ( -e $file )
    {
        #
        #  Load the history if we can.
        #
        if ( UNIVERSAL::can( $term, 'ReadHistory' ) )
        {
            $term->ReadHistory( $file );
        }
    }
}




=begin doc

  Run the input reading + dispatching loop.   We use the dispatch
 table already defined to handle input.

  Parsing of command line input is extremely minimal - we break the
 input line into "word" which is the first whitespace deliminated
 token on the line and "args" which is the remainder of the line.

  This is sufficient for our purposes.

=end doc

=cut

sub runMainLoop
{
    my ( $term ) = ( @_ );

    #
    #  Command loop.
    #
    while ( defined (my $line = $term->readline('xen-shell> ')) )
    {
        # Ignore empty lines.
        next if ( !length( $line ) );

        # Strip leading and trailing whitespace.
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;

        # If we have arguements then split them up.
        my ($word, @args) = split( /[ \t]/, $line );

        # Lookup command in our dispatch table.
        my $cmd = $dispatch{ lc( $word ) };

        if ( $cmd )
        {
            # Call the function with any arguments we might have.
            $cmd->{'sub'}->( join( " ", @args ) );

            # Add a successful line to our history, if we can.
            if ( UNIVERSAL::can( $term, 'add_history' ) )
            {
                $term->add_history( $line );
            }
        }
        else
        {
            if ( defined( $word ) && length( $word ) )
            {
                print "Unknown command: '$word' - type 'help' for help.\n";
            }
        }
    }
}




=begin doc

  Show uptime of the guest.

=end doc

=cut

sub show_uptime
{
    my $host_uptime = `uptime`;
    chomp( $host_uptime );
    print "Host : $host_uptime\n";

    my $seconds = "";
    my $cmd     = "sudo xm list --long $USER 2>/dev/null";

    open( RUNNING, $cmd . "|" );
    foreach my $line ( <RUNNING> )
    {
        if ( $line =~ /\(up_time[ \t]*([0-9]+)/ )
        {
            $seconds= $1;
        }
    }
    close( RUNNING );

    if ( defined( $seconds ) && length( $seconds ) )
    {
        my $days  = int($seconds/(24*60*60));
        my $hours = ($seconds/(60*60))%24;
        my $mins  = ($seconds/60)%60;
        my $secs  = $seconds%60;

        if ( length( $hours ) < 2 ) { $hours = "0" . $hours ; }
        if ( length( $mins ) < 2 )  { $mins  = "0" . $mins ; }
        if ( length( $secs ) < 2 )  { $secs  = "0" . $secs ; }

        print"Guest: $days days $hours:$mins:$secs\n";
    }
    else
    {
        print "Guest: Uptime not found\n";
    }
}



=begin doc

  Show status of the Xen guest:  Running/Shutdown

  If the guest is running then show its uptime too.

=end doc

=cut

sub show_status
{
    my $running = 0;

    #
    # See if the instance is running
    #
    my $cmd = "sudo xm list $USER 2>/dev/null | grep $USER";
    my $out = `$cmd`;
    if ( length( $out ) ) { $running = 1; }

    #
    # Show state.
    #
    if ( $running )
    {
        print "Guest : Running\n";

        my $seconds = "";
        my $cmd     = "sudo xm list --long $USER 2>/dev/null";

        open( RUNNING, $cmd . "|" );
        foreach my $line ( <RUNNING> )
        {
            if ( $line =~ /\(up_time[ \t]*([0-9]+)/ )
            {
                $seconds= $1;
            }
        }
        close( RUNNING );

        if ( defined( $seconds ) && length( $seconds ) )
        {
            my $days  = int($seconds/(24*60*60));
            my $hours = ($seconds/(60*60))%24;
            my $mins  = ($seconds/60)%60;
            my $secs  = $seconds%60;

            if ( length( $hours ) < 2 ) { $hours = "0" . $hours ; }
            if ( length( $mins ) < 2 )  { $mins  = "0" . $mins ; }
            if ( length( $secs ) < 2 )  { $secs  = "0" . $secs ; }

            print"Uptime: $days days $hours:$mins:$secs\n";
        }
    }
    else
    {
        print "Guest: Shutdown\n";
    }
}



=begin doc

  Show the user some help.

  When called with no arguments it will display all supported commands.

  If called with arguments then they we will show only help for the
 specified command(s).

=end doc

=cut

sub show_help
{
    my ( $term ) = ( @_ );

    #
    #  Help on a single command
    #
    if ( ( defined( $term ) ) && ( length( $term ))  )
    {
        foreach my $cmd ( split( /[ \t]/, $term ) )
        {

            # Lookup command in our dispatch table.
            my $c = $dispatch{ lc( $cmd ) };
            if ( $c )
            {
                my $args = $c->{'args'};

                if ( !defined( $args ) ) { $args = ''; }

                print "\nCommand: $cmd $args\n\n";
                print $c->{'help'} . "\n";
            }
            else
            {
                print "Unknown command '$cmd' - no help text available\n";
            }
        }
        return;
    }

    my $help =<<E_O_HELP;

xen-shell v$RELEASE.$VERSION

The following commands are available within this shell:

  boot      Boot your Xen guest.
  console   Gain access to your Xen guest via the serial console.
  exit      Exit this shell.
  help      Show general, or command-specific, help information.
  rdns      Setup Reverse DNS for allocated IP addresses
  reboot    Reboot your Xen guest.
  reimage   Reset your system to a pristine installation of Sarge.
  shutdown  Shut down your Xen guest.
  status    Show the status of your Xen guest.
  uptime    Show the uptime information of the host and guest systems.
  version   Show the version of this shell, and of Xen.

  For command-specific help run "help command".

E_O_HELP

    #
    #  Remove rdns + reimage if they are disabled.
    #
    if ( !defined( $dispatch{'rdns' } ) )
    {
        $help =~ s/[ \t]*rdns.*\n//gm;
    }
    if ( !defined( $dispatch{'reimage' } ) )
    {
        $help =~ s/[ \t]*reimage.*\n//gm;
    }

    print $help;

}




=begin doc

  Show the user the version of this shell, and of the Xen software installed.

=end doc

=cut

sub show_version
{
    my $xen = "";

    my $cmd     = "sudo xm info 2>/dev/null";

    open( INFO, $cmd . "|" );
    foreach my $line ( <INFO> )
    {
        if ( $line =~ /^xen_major.*: (.*)$/ )
        {
            $xen .= $1;
        }
        if ( $line =~ /^xen_minor.*: (.*)$/ )
        {
            $xen .= "." . $1;
        }
        if ( $line =~ /^xen_extra.*: (.*)$/ )
        {
            $xen .= $1;
        }
    }
    close( INFO );
    print "xen-shell $RELEASE.$VERSION";
    if ( length( $xen ) )
    {
        print " running on Xen version $xen";
    }

    print "\n";
}



=begin doc

  Control reverse DNS for this user.

  This allows the user to view/modify the contents of ~/ips.txt

  Another script is required to actually take the contents of the files
 and perform the DNS updates.

=end doc

=cut

sub do_rdns
{
    my ( $args ) = ( @_ );

    if ( !defined( $args ) || ( !length( $args ) ) )
    {
        # No arguments just show the current IP setup.
        open( CURRENT, "<", "/home/$USER/ips.txt" ) or return;
        while(<CURRENT>)
        {
            print;
        }
        close( CURRENT );
        return;
    }


    #
    #  We have an agument.  Assume it is of the form:
    #
    #  rdns xx.xx.xx.xx some.host.name
    #
    my ( $ip, $host ) = split( /[ \t]/, $args );

    #
    #  Test that the arguments are the right way round!
    #
    if ( $ip !~ /^([0-9.]*)$/ )
    {
        print "The IP address you've specified isn't numerical: '$ip'\n";
        return;
    }

    #
    #  OK we have a host and IP, we want to open the users file
    # and update the hostname if it matches.
    #
    my $updated = 0;
    my @lines;

    open( CURRENT, "<", "/home/$USER/ips.txt" ) or return;
    while(<CURRENT>)
    {
        my $line      = $_;
        my ( $i, $h ) = split( /[ \t]/, $line );
        if ( $i eq $ip )
        {
            $line    = $ip . " " . $host . "\n";
            $updated = 1;
        }

        push @lines, $line;
    }
    close( CURRENT );

    #
    #  If we updated save the new details.
    #
    if ( $updated )
    {
        open( NEW, ">", "/home/$USER/ips.txt" );
        foreach my $l ( @lines )
        {
            print NEW $l;
        }
        close( NEW );
        print "Set the reverse DNS for $ip to $host\n";
        print "Please wait an hour or two for it to take effect\n";
    }
    else
    {
        print "IP details for IP '$ip' not found.  Ignoring\n";
    }
}



=begin doc

  Reboot the Xen guest.

=end doc

=cut

sub do_reboot
{
    print "Rebooting instance: $USER\n";
    system( "sudo xm reboot $USER" );
}



=begin doc

  Allow the machine to be reinitialised to a fresh installation of
 their Xen guest.

  This ultimately invokes ~$USER/image.sh to do the work.

=end doc

=cut

sub do_reimage
{
    if (! -x "/home/$USER/image.sh" )
    {
        print "There is no reimaging script for user $USER\n";
        print "Skipping.\n";
        return;
    }

    print "Reimaging instance: $USER\n";

    #
    # See if the instance is running
    #
    my $running = 0;
    my $cmd = "sudo xm list $USER 2>/dev/null | grep $USER";
    my $out = `$cmd`;
    if ( length( $out ) )
    {
        print "Xen guest running.\n";
        print "Please run 'shutdown' first\n";
        return;
    }
    else
    {
        print "Machine not running, proceeding\n";
    }


    #
    #  Run the xm-reimage, either from /usr/bin, or /usr/local/bin.
    #
    if ( -x "/usr/bin/xm-reimage" )
    {
        system( "/usr/bin/xm-reimage $USER" );
        print "You may now boot your installation\n";
    }
    elsif ( -x "/usr/local/bin/xm-reimage" )
    {
        system( "/usr/local/bin/xm-reimage $USER" );
        print "You may now boot your installation\n";
    }
    else
    {
        print "ERROR:  'xm-reimage' not found.\n";
        print "ERROR:  Please report this as a bug to your server admin.\n";
    }
}



=begin doc

  Shutdown the instance.

=end doc

=cut

sub do_shutdown
{
    print "Shutting down instance: $USER\n";
    system( "sudo xm shutdown $USER" );
}



=begin doc

  Start the instance.

=end doc

=cut

sub do_boot
{
    print "Booting instance: $USER\n";
    system( "sudo xm create $USER.cfg" );
    print "Use 'console' to see the bootup messages.\n";
}



=begin doc

  Connect to the serial console of the running Xen guest.

=end doc

=cut

sub do_console
{
    print "Running console for $USER - exit with Ctrl+]\n";
    system( "sudo xm console $USER" );
}



=begin doc

  Allow the user to change their login password, if password-based
 authentication is in use.

  Note this function is disabled if ~/.ssh/authorized_keys is present.

=end doc

=cut

sub do_password
{
    system( "passwd" );
}



=begin doc

 Exit this shell, first saving any command history.

=end doc

=cut

sub do_exit
{
    my $file = $ENV{'HOME'} . "/" . ".xen-shell";

    #
    #  Save the history if the term module can.
    #
    if ( UNIVERSAL::can( $term, 'WriteHistory' ) )
    {
        $term->WriteHistory( $file );
    }

    exit;
}



=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

 $Id: xen-shell,v 1.56 2006-12-10 17:31:21 steve Exp $

=cut

=head1 LICENSE

Copyright (c) 2005-2006 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut
