#!/usr/bin/perl
#
# Provide a simple command line shell program which can be used as
# the login shell for a Xen user.
#
# This provides basic abilities for the user to control their instance.
#
# Steve
# --
#

use strict;
use warnings;
use English;

#
#  Version number
#
my $VERSION   = '$Revision: 1.25 $';
if ( $VERSION =~ /(1.[0-9.]+) / ) { $VERSION = $1; }


#
# Get the username of the person who is currently running the software.
#
# Use this form to make sure even when running under sudo, etc, it works.
#
my $USER = getpwuid( $REAL_USER_ID );


#
#  Dispatch table which contains the mappings between the commands
# we make available and the routine which implements that behaviour and
# the help text to show.
#
#  This is a hash of hashes.  Obviously.
#
my %dispatch =
(
   "boot" =>
     {
        sub => \&do_boot,
       help => "Start the Xen guest, if it is not running.",
     },
   "console" =>
     {
        sub => \&do_console,
       help => "Connect to the serial console of the Xen instance using GNU Screen.\n\nTo exit the serial prompt type 'Ctrl+]'\nYou may instead exit screen with 'Ctrl+a k', or 'Ctrl+a d'.",
     },
   "exit" =>
     {
        sub => \&do_exit,
       help => "Exit this shell.",
     },
   "help" =>
     {
        sub => \&show_help,
       help => "Show help about the specified command, or all commands.",
     },
  "quit" =>   # Dupe: exit
     {
        sub => \&do_exit,
       help => "Exit this shell.",
     },
   "reboot" =>
     {
        sub => \&do_reboot,
       help => "Reboot the Xen guest.",
     },
   "reimage" =>
     {
        sub => \&do_reimage,
       help => "Erase your Xen guest and reinitialise it to a fresh installation of Sarge.",
     },
   "serial" => # Dupe: console
     {
        sub => \&do_console,
       help => "Connect to the serial console of the Xen instance using GNU Screen.\n\nTo exit the serial prompt type 'Ctrl+]'\nYou may instead exit screen with 'Ctrl+a k', or 'Ctrl+a d'.",
     },
   "shutdown" =>
     {
        sub => \&do_shutdown,
       help => "Shutdown the Xen guest.",
     },
   "status" =>
     {
        sub => \&show_status,
        help => "Show whether the Xen guest is running or not.",
     },
   "uptime" =>
     {
        sub => \&show_uptime,
        help => "Show the uptime of the host system.",
     },
  );




#
# Sanity check our host and user.
#
sanityCheck();


#
# Show our shell banner.
#
showBanner();


#
#  Create the readline interface.
#
my $term = createTerm();


#
#  Load command history.
#
loadHistory( $term );


#
#  Run our command loop.
#
runMainLoop( $term );


#
#  Never reached
#
exit;





=head2 sanityCheck

 Sanity check that we can load the modules we require, and also make sure
the current user has a xen guest on this host machine.

=cut

sub sanityCheck
{
    #
    #  Test we have the perl modules we need.
    #
    BEGIN {
        eval {
            require Term::ReadLine;
            require Term::ReadLine::Gnu;
        };
    };
    if ( $@ )
    {
        print "Package 'Term::ReadLine::Gnu' not installed.\n";
        print "Aborting\n";
        exit;
    }

    #
    #  Test that the current user has a sane name
    #
    if ( $USER !~ /^([a-zA-Z]+)$/ )
    {
        print "User $USER contains non-alphabetical characters\n";
        print "Aborting\n";
        exit;
    }

    #
    #  Test that the user has a Xen guest
    #
    if ( ! -e "/etc/xen/$USER.cfg" )
    {
        print "User '$USER' doesn't have a Xen guest on this host.\n";
        print "Aborting\n";
        exit;
    }
}



=head2 showBanner

 Show the banner of this shell - used when we start up.

=cut

sub showBanner
{
    print "xen-shell v$VERSION - type 'help' for help.\n";
}



=head2 createTerm

  Create the terminal interface, complete with command completion.

=cut

sub createTerm
{
    my $term = new Term::ReadLine 'xen-shell';

    #
    # Process our dispatch table to determine which commands
    # are available.
    #
    my @cmds = ();
    foreach my $cmd ( keys %dispatch )
    {
        push @cmds, $cmd;
    }

    #
    #  Add completion
    #
    my $attribs = $term->Attribs;
    $attribs->{completion_entry_function} = $attribs->{list_completion_function};
    $attribs->{completion_word}           = \@cmds;

    #
    #  Return it
    #
    return( $term );
}



=head2 loadHistory

  If the user has a xen-shell history load it up.

=cut

sub loadHistory
{
    my ( $term ) = ( @_ );

    #
    #  Load the file.
    #
    my $file = $ENV{'HOME'} . "/" . ".xen-shell";
    if ( -e $file )
    {
        $term->ReadHistory( $file );
    }
}




=head2 runMainLoop

  Run the input reading + dispatching loop.   We use the dispatch
 table already defined to handle input.

  Parsing of command line input is extremely minimal - we break the
 input line into "word" which is the first whitespace deliminated
 token on the line and "args" which is the remainder of the line.

  This is sufficient for our purposes.

=cut

sub runMainLoop
{
    my ( $term ) = ( @_ );

    #
    #  Command loop.
    #
    while ( defined (my $line = $term->readline('xen-shell> ')) )
    {
        # Ignore empty lines.
        next if ( !length( $line ) );

        # Strip leading and trailing whitespace.
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;

        # If we have arguements then split them up.
        my ($word, @args) = split( /[ \t]/, $line );

        # Lookup command in our dispatch table.
        my $cmd = $dispatch{ lc( $word ) };

        if ( $cmd )
        {
            # Call the function with any arguments we might have.
            $cmd->{'sub'}->( join( " ", @args ) );

            # Add a successful line to our history
            $term->add_history( $line );
        }
        else
        {
            print "Unknown command: '$word' - type 'help' for help.\n";
        }
    }
}




=head2 show_uptime

  Show uptime of the guest.

=cut

sub show_uptime
{
    my $host_uptime = `uptime`;
    chomp( $host_uptime );
    print "Host : $host_uptime\n";
}


=head2 show_status

  Show status of the guest system:  Running/Shutdown

=cut

sub show_status
{
    my $running = 0;

    #
    # See if the instance is running
    #
    my $cmd = "sudo xm list $USER 2>/dev/null | grep $USER";
    my $out = `$cmd`;
    if ( length( $out ) ) { $running = 1; }

    #
    # Show state.
    #
    if ( $running )
    {
        print "Guest: Running\n";
    }
    else
    {
        print "Guest: Shutdown\n";
    }
}



=sub show_help

  Show the user some help

=cut

sub show_help
{
    my ( $term ) = ( @_ );

    #
    #  Help on a single command
    #
    if ( ( defined( $term ) ) && ( length( $term ))  )
    {
        foreach my $cmd ( split( /[ \t]/, $term ) )
        {
            print "\nCommand: $cmd\n\n";

            # Lookup command in our dispatch table.
            my $c = $dispatch{ lc( $cmd ) };
            if ( $c )
            {
                print $c->{'help'} . "\n";
            }
            else
            {
                print "Unknown command '$cmd' - no help text available\n";
            }
        }
        return;
    }

    print <<E_O_HELP;

xen-shell v$VERSION

The following commands are available within this shell:

  boot      Boot your Xen guest.
  console   Gain access to your Xen guest via the serial console.
  exit      Exit this shell.
  help      Show general, or command-specific, help information.
  reboot    Reboot your Xen guest.
  shutdown  Shut down your Xen guest.
  status    Show the status of your Xen guest.
  uptime    Show the uptime information of the host system.

  For command-specific help run "help command".

E_O_HELP
}


=head2 do_reboot

  Reboot the instance.

=cut

sub do_reboot
{
    print "Rebooting instance: $USER\n";
    system( "sudo xm reboot $USER" );
}



=head2 do_reimage

  Allow the machine to be reinitialised to a fresh installation of
 their Xen guest.  This ultimately invokes ~$USER/image.sh to do
 the work.

=cut

sub do_reimage
{
    if (! -x "/home/$USER/image.sh" )
    {
        print "There is no reimaging script for user $USER\n";
        print "Skipping.\n";
        return;
    }

    print "Reimaging instance: $USER\n";

    #
    # See if the instance is running
    #
    my $running = 0;
    my $cmd = "sudo xm list $USER 2>/dev/null | grep $USER";
    my $out = `$cmd`;
    if ( length( $out ) )
    {
        print "Xen guest running.\n";
        print "Please run 'shutdown' first\n";
        return;
    }
    else
    {
        print "Machine not running, proceeding\n";
    }

    system( "/usr/local/bin/xm-reimage $USER" );
    print "You may now boot your installation\n";
}



=head2 do_shutdown

  Shutdown the instance.

=cut

sub do_shutdown
{
    print "Shutting down instance: $USER\n";
    system( "sudo xm shutdown $USER" );
}


=head2 do_boot

  Start the instance.

=cut

sub do_boot
{
    print "Booting instance: $USER\n";
    system( "sudo xm create $USER.cfg" );
    print "Use 'console' to see the bootup messages.\n";
}


=head2 do_console

  Run GNU Screen with the console output of Xen.

=cut

sub do_console
{
    print "Running console for $USER\n";
    system( "xm-console" );
}


=head2 do_exit

 Exit this shell

=cut

sub do_exit
{
    my $file = $ENV{'HOME'} . "/" . ".xen-shell";

    $term->WriteHistory( $file );

    exit;
}
