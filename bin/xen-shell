#!/usr/bin/perl -w

=head1 NAME

xen-shell - Provide a console interface to control Xen guests.

=cut


=head1 SYNOPSIS

  xen-shell [options]

  Options:

   --help     Show brief help intstructions.
   --manual   Show more complete help.
   --version  Show the version of the software.

=cut


=head1 DESCRIPTION

  xen-shell provides a simple console interface to allow a user to
 control a single Xen instance which is running upon the localhost.

  The Xen instance is assumed to have the same name as the users login
 name, and will not work if that isn't the case.

  Features include:

=over 8

=item Command line completion

=item Command history

=item The ability to run within GNU Screen to allow longrunning jobs to be completed "offline".

=back

=cut


=head1 REIMAGING SUPPORT

  The shell has a built-in "reimage" command which can be used by users
 to reinitialize their system.

  The reimage command itself does nothing, it merely executes the file
 "image.sh" from the users home directory, it is assumed that you will
 write your own script - perhaps to invoke "xen-create-image" to do
 the real job.

  A sample script looks like this:

=for example begin
#!/bin/sh
#
# Reimaging script for the user skx.
#

xen-create-image --hostname=skx.xen-hosting.net --ip=1.2.3.4 \
  --size=9.5Gb --swap=512Mb --memory=256Mb --force

=for example end

  If ~$USER/image.sh doesn't exist, or isn't executable, this command
 will be disabled.

=cut


=head2 REVERSE DNS SUPPORT

  This shell contains a built-in system for allowing a Xen-shell user to
 manipulate reverse DNS entries for IP addresses.  The shell itself doesn't
 do this, instead a user will manipulate a simple text file in their home
 directory.

  Create the file /home/$USER/ips.txt with contents of the following form:

=for example begin

192.168.1.1 foo.my.flat
192.168.1.2 bar.my.flat
192.168.1.3 baz.my.flta

=for example end

  If this file is present then the "rdns" command will be available to
 that user.  The "rdns" command, when executed with no arguments will
 simply display this file.

  When the user attempts to set reverse DNS the file will be updated.

  It is assumed you will have your own cronjob to actually read these
 files and perform the DNS updates, the shell support is just half the
 implementation.

  If the file doesn't exist, or isn't writable, then the command will
 be disabled.

=cut



=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

 $Id: xen-shell,v 1.40 2006-08-15 19:15:18 steve Exp $

=cut


=head1 LICENSE

Copyright (c) 2005-2006 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut





use strict;
use warnings;
use English;
use Getopt::Long;
use Pod::Usage;


#
#  Version number of this script.
#
my $VERSION   = '$Revision: 1.40 $';
if ( $VERSION =~ /(1.[0-9.]+) / ) { $VERSION = $1; }


#
# Get the username of the person who is currently running the software.
#
my $USER = getpwuid( $REAL_USER_ID );


#
#  Dispatch table which contains the mapping between the commands
# we make available and the routine which implements that behaviour.
#
#  The help-text is also specified here.
#
#
my %dispatch =
  (
   "boot" =>
     {
        sub => \&do_boot,
       help => "Start the Xen guest, if it is not running.",
     },
   "console" =>
     {
        sub => \&do_console,
       help => "Connect to the serial console of the Xen instance using GNU Screen.\n\nTo exit the serial prompt type 'Ctrl+]'\nYou may instead exit screen with 'Ctrl+a k', or 'Ctrl+a d'.",
     },
   "exit" =>
     {
        sub => \&do_exit,
       help => "Exit this shell.",
     },
   "help" =>
     {
        sub => \&show_help,
       args => "[command]",
       help => "Show help about the specified command, or all commands if no command is specified.",
     },
  "quit" =>   # Dupe: exit
     {
        sub => \&do_exit,
       help => "Exit this shell.",
     },
   "rdns" =>
     {
       sub  => \&do_rdns,
       args => "[ipaddress some.host.name]",
       help => "Setup Reverse DNS for allocated IP addresses.\n\nWhen called with no arguments show current reverse DNS details.",
     },
   "reboot" =>
     {
        sub => \&do_reboot,
       help => "Reboot the Xen guest.",
     },
   "reimage" =>
     {
        sub => \&do_reimage,
       help => "Erase your Xen guest and reinitialise it to a fresh installation of Sarge.",
     },
   "serial" => # Dupe: console
     {
        sub => \&do_console,
       help => "Connect to the serial console of the Xen instance using GNU Screen.\n\nTo exit the serial prompt type 'Ctrl+]'\nYou may instead exit screen with 'Ctrl+a k', or 'Ctrl+a d'.",
     },
   "shutdown" =>
     {
        sub => \&do_shutdown,
       help => "Shutdown the Xen guest.",
     },
   "status" =>
     {
        sub => \&show_status,
        help => "Show whether the Xen guest is running or not.",
     },
   "uptime" =>
     {
        sub => \&show_uptime,
        help => "Show the uptime of the host & guest systems.",
     },
   "version" =>
     {
        sub => \&show_version,
        help => "Show the version of this shell, and of Xen.",
     },
  );


#
#  Parse the command line arguments.
#
parseCommandLineArguments();


#
# Sanity check our host and user.
#
sanityCheck();


#
# Remove commands the user can't access.
#
removeCommands();


#
# Show our banner.
#
showBanner();


#
#  Create the readline interface.
#
my $term = createTerm();


#
#  Load any command history which might be present.
#
loadHistory( $term );


#
#  Run our command loop.
#
runMainLoop( $term );


#
#  Never reached
#
exit;




=begin doc

  Parse any command line options which might be present

=cut

sub parseCommandLineArguments
{
    my $SHOW_HELP    = 0;
    my $SHOW_MANUAL  = 0;
    my $SHOW_VERSION = 0;

    #
    #  Parse options.
    #
    GetOptions(
              "help",         \$SHOW_HELP,
              "manual",       \$SHOW_MANUAL,
              "version",      \$SHOW_VERSION
             );

    pod2usage(1) if $SHOW_HELP;
    pod2usage(-verbose => 2 ) if $SHOW_MANUAL;

    if ( $SHOW_VERSION )
    {
       print "xen-shell v$VERSION\n";
       exit;
    }
}


=begin doc

 Sanity check that we can load the modules we require, and also make sure
the current user has a xen guest on this host machine.

=cut

sub sanityCheck
{
    #
    #  Test we have the perl modules we need.
    #
    BEGIN {
        eval {
            require Term::ReadLine;
            require Term::ReadLine::Gnu;
        };
    };
    if ( $@ )
    {
        print "Package 'Term::ReadLine::Gnu' not installed.\n";
        print "Aborting\n";
        exit;
    }

    #
    #  Test that the current user has a sane name
    #
    if ( $USER !~ /^([a-zA-Z]+)$/ )
    {
        print "User $USER contains non-alphabetical characters\n";
        print "Aborting\n";
        exit;
    }

    #
    #  Test that the user has a Xen guest
    #
    if ( ! -e "/etc/xen/$USER.cfg" )
    {
        print "User '$USER' doesn't have a Xen guest on this host.\n";
        print "Aborting\n";
        exit;
    }
}



=begin doc

  Remove any commands which the current user cannot use.

=cut

sub removeCommands
{
    #
    #  reimage
    #
    if ( ! -x "/home/$USER/image.sh" )
    {
        $dispatch{ 'reimage' } = undef;
        delete( $dispatch{ 'reimage' } );
    }

    #
    #  rdns
    #
    if ( ! -e "/home/$USER/ips.txt" )
    {
        $dispatch{ 'rdns' } = undef;
        delete( $dispatch{ 'rdns' } );
    }
}



=begin doc

 Show the banner of this shell - used when we start up.

=cut

sub showBanner
{
    print "xen-shell v$VERSION - type 'help' for help.\n";
}



=begin doc

  Create the terminal interface, complete with command completion.

=cut

sub createTerm
{
    my $term = new Term::ReadLine 'xen-shell';

    #
    # Process our dispatch table to determine which commands
    # are available.
    #
    my @cmds = ();
    foreach my $cmd ( keys %dispatch )
    {
        push @cmds, $cmd;
    }

    #
    #  Add completion
    #
    my $attribs = $term->Attribs;
    $attribs->{completion_entry_function} = $attribs->{list_completion_function};
    $attribs->{completion_word}           = \@cmds;

    #
    #  Return it
    #
    return( $term );
}



=begin doc

  If the user has a xen-shell history load it up.

=cut

sub loadHistory
{
    my ( $term ) = ( @_ );

    #
    #  Load the file.
    #
    my $file = $ENV{'HOME'} . "/" . ".xen-shell";
    if ( -e $file )
    {
        $term->ReadHistory( $file );
    }
}




=begin doc

  Run the input reading + dispatching loop.   We use the dispatch
 table already defined to handle input.

  Parsing of command line input is extremely minimal - we break the
 input line into "word" which is the first whitespace deliminated
 token on the line and "args" which is the remainder of the line.

  This is sufficient for our purposes.

=cut

sub runMainLoop
{
    my ( $term ) = ( @_ );

    #
    #  Command loop.
    #
    while ( defined (my $line = $term->readline('xen-shell> ')) )
    {
        # Ignore empty lines.
        next if ( !length( $line ) );

        # Strip leading and trailing whitespace.
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;

        # If we have arguements then split them up.
        my ($word, @args) = split( /[ \t]/, $line );

        # Lookup command in our dispatch table.
        my $cmd = $dispatch{ lc( $word ) };

        if ( $cmd )
        {
            # Call the function with any arguments we might have.
            $cmd->{'sub'}->( join( " ", @args ) );

            # Add a successful line to our history
            $term->add_history( $line );
        }
        else
        {
            if ( defined( $word ) && length( $word ) )
            {
                print "Unknown command: '$word' - type 'help' for help.\n";
            }
        }
    }
}




=begin doc

  Show uptime of the guest.

=cut

sub show_uptime
{
    my $host_uptime = `uptime`;
    chomp( $host_uptime );
    print "Host : $host_uptime\n";

    my $seconds = "";
    my $cmd     = "sudo xm list --long $USER 2>/dev/null";

    open( RUNNING, $cmd . "|" );
    foreach my $line ( <RUNNING> )
    {
        if ( $line =~ /\(up_time[ \t]*([0-9]+)/ )
        {
            $seconds= $1;
        }
    }
    close( RUNNING );

    if ( defined( $seconds ) && length( $seconds ) )
    {
        my $days  = int($seconds/(24*60*60));
        my $hours = ($seconds/(60*60))%24;
        my $mins  = ($seconds/60)%60;
        my $secs  = $seconds%60;

        if ( length( $hours ) < 2 ) { $hours = "0" . $hours ; }
        if ( length( $mins ) < 2 )  { $mins  = "0" . $mins ; }
        if ( length( $secs ) < 2 )  { $secs  = "0" . $secs ; }

        print"Guest: $days days $hours:$mins:$secs\n";
    }
    else
    {
        print "Guest: Uptime not found\n";
    }
}


=begin doc

  Show status of the guest system:  Running/Shutdown

=cut

sub show_status
{
    my $running = 0;

    #
    # See if the instance is running
    #
    my $cmd = "sudo xm list $USER 2>/dev/null | grep $USER";
    my $out = `$cmd`;
    if ( length( $out ) ) { $running = 1; }

    #
    # Show state.
    #
    if ( $running )
    {
        print "Guest : Running\n";

        my $seconds = "";
        my $cmd     = "sudo xm list --long $USER 2>/dev/null";

        open( RUNNING, $cmd . "|" );
        foreach my $line ( <RUNNING> )
        {
            if ( $line =~ /\(up_time[ \t]*([0-9]+)/ )
            {
                $seconds= $1;
            }
        }
        close( RUNNING );

        if ( defined( $seconds ) && length( $seconds ) )
        {
            my $days  = int($seconds/(24*60*60));
            my $hours = ($seconds/(60*60))%24;
            my $mins  = ($seconds/60)%60;
            my $secs  = $seconds%60;

            if ( length( $hours ) < 2 ) { $hours = "0" . $hours ; }
            if ( length( $mins ) < 2 )  { $mins  = "0" . $mins ; }
            if ( length( $secs ) < 2 )  { $secs  = "0" . $secs ; }

            print"Uptime: $days days $hours:$mins:$secs\n";
        }
    }
    else
    {
        print "Guest: Shutdown\n";
    }
}



=begin doc

  Show the user some help

=cut

sub show_help
{
    my ( $term ) = ( @_ );

    #
    #  Help on a single command
    #
    if ( ( defined( $term ) ) && ( length( $term ))  )
    {
        foreach my $cmd ( split( /[ \t]/, $term ) )
        {

            # Lookup command in our dispatch table.
            my $c = $dispatch{ lc( $cmd ) };
            if ( $c )
            {
                my $args = $c->{'args'};

                if ( !defined( $args ) ) { $args = ''; }

                print "\nCommand: $cmd $args\n\n";
                print $c->{'help'} . "\n";
            }
            else
            {
                print "Unknown command '$cmd' - no help text available\n";
            }
        }
        return;
    }

    print <<E_O_HELP;

xen-shell v$VERSION

The following commands are available within this shell:

  boot      Boot your Xen guest.
  console   Gain access to your Xen guest via the serial console.
  exit      Exit this shell.
  help      Show general, or command-specific, help information.
  rdns      Setup Reverse DNS for allocated IP addresses
  reboot    Reboot your Xen guest.
  reimage   Reset your system to a pristine installation of Sarge.
  shutdown  Shut down your Xen guest.
  status    Show the status of your Xen guest.
  uptime    Show the uptime information of the host and guest systems.
  version   Show the version of this shell, and of Xen.

  For command-specific help run "help command".

E_O_HELP
}




=begin doc

  Show the user the version of this shell.

=cut

sub show_version
{
    my $xen = "";

    my $cmd     = "sudo xm info 2>/dev/null";

    open( INFO, $cmd . "|" );
    foreach my $line ( <INFO> )
    {
        if ( $line =~ /^xen_major.*: (.*)$/ )
        {
            $xen .= $1;
        }
        if ( $line =~ /^xen_minor.*: (.*)$/ )
        {
            $xen .= "." . $1;
        }
        if ( $line =~ /^xen_extra.*: (.*)$/ )
        {
            $xen .= $1;
        }
    }
    close( INFO );
    print "xen-shell $VERSION";
    if ( length( $xen ) )
    {
        print " running on Xen version $xen";
    }

    print "\n";
}



=begin doc

  Control reverse DNS for this user.  This doesn't actually do
 anything related to DNS itself, it merely updates a file "ips.txt"
 in the users home directory.

  Another script is required to do the real work.

=cut

sub do_rdns
{
    my ( $args ) = ( @_ );

    if ( !defined( $args ) || ( !length( $args ) ) )
    {
        # No arguments just show the current IP setup.
        open( CURRENT, "<", "/home/$USER/ips.txt" ) or return;
        while(<CURRENT>)
        {
            print;
        }
        close( CURRENT );
        return;
    }


    #
    #  We have an agument.  Assume it is of the form:
    #
    #  rdns xx.xx.xx.xx some.host.name
    #
    my ( $ip, $host ) = split( /[ \t]/, $args );

    #
    #  Test that the arguments are the right way round!
    #
    if ( $ip !~ /^([0-9.]*)$/ )
    {
        print "The IP address you've specified isn't numerical: '$ip'\n";
        return;
    }

    #
    #  OK we have a host and IP, we want to open the users file
    # and update the hostname if it matches.
    #
    my $updated = 0;
    my @lines;

    open( CURRENT, "<", "/home/$USER/ips.txt" ) or return;
    while(<CURRENT>)
    {
        my $line      = $_;
        my ( $i, $h ) = split( /[ \t]/, $line );
        if ( $i eq $ip )
        {
            $line    = $ip . " " . $host . "\n";
            $updated = 1;
        }

        push @lines, $line;
    }
    close( CURRENT );

    #
    #  If we updated save the new details.
    #
    if ( $updated )
    {
        open( NEW, ">", "/home/$USER/ips.txt" );
        foreach my $l ( @lines )
        {
            print NEW $l;
        }
        close( NEW );
        print "Set the reverse DNS for $ip to $host\n";
        print "Please wait an hour or two for it to take effect\n";
    }
    else
    {
        print "IP details for IP '$ip' not found.  Ignoring\n";
    }
}


=begin doc

  Reboot the instance.

=cut

sub do_reboot
{
    print "Rebooting instance: $USER\n";
    system( "sudo xm reboot $USER" );
}



=begin doc

  Allow the machine to be reinitialised to a fresh installation of
 their Xen guest.  This ultimately invokes ~$USER/image.sh to do
 the work.

=cut

sub do_reimage
{
    if (! -x "/home/$USER/image.sh" )
    {
        print "There is no reimaging script for user $USER\n";
        print "Skipping.\n";
        return;
    }

    print "Reimaging instance: $USER\n";

    #
    # See if the instance is running
    #
    my $running = 0;
    my $cmd = "sudo xm list $USER 2>/dev/null | grep $USER";
    my $out = `$cmd`;
    if ( length( $out ) )
    {
        print "Xen guest running.\n";
        print "Please run 'shutdown' first\n";
        return;
    }
    else
    {
        print "Machine not running, proceeding\n";
    }

    system( "/usr/local/bin/xm-reimage $USER" );
    print "You may now boot your installation\n";
}



=begin doc

  Shutdown the instance.

=cut

sub do_shutdown
{
    print "Shutting down instance: $USER\n";
    system( "sudo xm shutdown $USER" );
}


=begin doc

  Start the instance.

=cut

sub do_boot
{
    print "Booting instance: $USER\n";
    system( "sudo xm create $USER.cfg" );
    print "Use 'console' to see the bootup messages.\n";
}


=begin doc

  Run GNU Screen with the console output of Xen.

=cut

sub do_console
{
    print "Running console for $USER - exit with Ctrl+]\n";
    system( "sudo xm console $USER" );
}


=begin doc

 Exit this shell

=cut

sub do_exit
{
    my $file = $ENV{'HOME'} . "/" . ".xen-shell";

    $term->WriteHistory( $file );

    exit;
}


=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

 $Id: xen-shell,v 1.40 2006-08-15 19:15:18 steve Exp $

=cut

=head1 LICENSE

Copyright (c) 2005-2006 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut
